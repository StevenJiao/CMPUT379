#include <stdio.h>
#include <string.h>	//strlen
#include <stdlib.h>	//strlen
#include <sys/socket.h>
#include <arpa/inet.h>	//inet_addr
#include <unistd.h>	//write
#include <pthread.h> //for threading , link with lpthread
#include <semaphore.h>
#include <iostream>
#include <vector>
#include <map>
#include <sys/poll.h>

#include "tands.c"
#include "serverwriter.cpp"

using namespace std;

// for storing client jobs
map<string, int> summary;

// for storing the total number of jobs done
int jobNum = 1;

// mutex var for accessing the jobNum
sem_t jobMutex;

// writer reference for threads
serverwriter writer;

/**
 * @brief for handling the threads generated by the server for handling multiple clients at once
 * 
 * @param socket_desc 	the pointer to the socket
 * @return void* 		the return pointer; currently only returns an int of value 0
 */
void *connection_handler(void *socket_desc) {
	// Get the socket descriptor
	int sock = *(int*)socket_desc;
	int read_size;
	vector<char> buf(5000); 

	// see if we have data to read from client
	while( (read_size = recv(sock , buf.data() , buf.size() , 0)) > 0 ) {
		// get string version of data
		string s(buf.data());
		// parse job and client name
		string event = s.substr(0, s.find("-"));
		string clientName = s.substr(s.find("-") + 1, string::npos);
		clientName.shrink_to_fit();
		// get the job duration
		int n = stoi(event.substr(1, string::npos));
		// if this is the start of server working, start the timer
		if (summary.size() == 0) { writer.setStartTime(); }
		// initialize our summary for the client if it does not already exist
		if (summary.find(clientName) == summary.end()) { summary[clientName] = 0; }

		// lock job read from client
		sem_wait(&jobMutex);
		
		// log the work and perform it
		writer.writeToFile(event, n, jobNum, clientName);
		Trans(n);
		// log that we're done
		string doneMessage = "D" + to_string(jobNum);
		writer.writeToFile(doneMessage, n, jobNum, clientName);
		// Send the message back to client
		write(sock , doneMessage.c_str(), doneMessage.length());
		// increase job count
		jobNum++;
		
		// release job
		sem_post(&jobMutex);

		// increase job count for client
		summary[clientName]++;
		// reset buffer
		buf.clear();
		buf.resize(5000);
	}
	
	// client disconnected check
	if(read_size == 0) {
		fflush(stdout);
	}
	else if(read_size < 0) {
		perror("recv failed");
	}
		
	// Free the socket pointer
	free(socket_desc);
	
	return 0;
}

/**
 * @brief A simple server that can handle multiple client connections
 * 
 */
int main(int argc , char *argv[]) {
	// initialize our mutex and other vars for connection
	sem_init(&jobMutex, 0, 1);
	int socket_desc , client_sock , c , *new_sock, rc;
	struct sockaddr_in server , client;
	int portNum = 8888; // lucky number
	vector<char> serverHostName(2000);
	string fullServerName;
	// initialize structures for our polling 
	struct pollfd fds[200];
	int nfds = 1, timeout,  current_size = 0;

	// create the host name
	gethostname(serverHostName.data(), serverHostName.size());
	fullServerName = serverHostName.data();
	fullServerName += "." + to_string(getpid());

	if (argc == 2) {
		portNum = stoi(argv[1]);
	}
	else {
		printf("Invalid number of inputs given.");
		return 1;
	}
	
	// Create socket
	socket_desc = socket(AF_INET , SOCK_STREAM , 0);
	if (socket_desc == -1) {
		perror("Could not create socket");
		return 1;
	}

	// setup polling structure 
	memset(fds, 0 , sizeof(fds));
	fds[0].fd = socket_desc;
	fds[0].events = POLLIN;
	// set timeout of polling to be 30s, in ms
	timeout = (30 * 1000);
	
	// Prepare the sockaddr_in structure
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons(portNum);
	
	// Bind
	if( bind(socket_desc,(struct sockaddr *)&server , sizeof(server)) < 0) {
		perror("bind() failed. Error");
		return 1;
	}
	
	// Listen for up to 11 threads - 1 more than max as per instructions here https://eclass.srv.ualberta.ca/mod/forum/discuss.php?d=1859847
	listen(socket_desc , 11);

	// get our writer
	writer = serverwriter(fullServerName, portNum);
	
	// Accept continuously check for connections
	c = sizeof(struct sockaddr_in);
	while( true ) {
		// check for connections with timeout
		rc = poll(fds, nfds, timeout);

		// poll failed
		if (rc < 0) {
			perror("poll() failed");
			break;
		}
		// reached timeout
		if (rc == 0) {
			break;
		}

		// accept the connection
		client_sock = accept(socket_desc, (struct sockaddr *)&client, (socklen_t*)&c);
		if (client_sock < 0) {
			perror("accept() failed");
			return 1;
		}
		// give it to thread to perform work
		pthread_t sniffer_thread;
		new_sock = new int;
		*new_sock = client_sock;
		if( pthread_create(&sniffer_thread , NULL,  connection_handler, (void*) new_sock) < 0) {
			perror("could not create thread");
			return 1;
		}
	}

	// write our summary out for each client
	writer.appendSummary(summary, jobNum-1);
	
	return 0;
}
